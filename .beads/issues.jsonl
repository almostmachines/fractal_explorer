{"id":"fractal_explorer-0gu","title":"Verify non-GUI build isolation","description":"# Task: Verify Non-GUI Build Isolation\n\n**Parent Epic**: Epic: Build Verification and Testing\n\n## Objective\nConfirm that building without `--features gui` produces a lightweight binary with no GUI dependencies. This validates our feature gating strategy.\n\n## Verification Steps\n\n### 1. Clean build without feature\n```bash\n# Remove any cached artifacts\ncargo clean\n\n# Build without GUI feature\ncargo build\n```\nExpected: Success, no mention of winit/pixels/egui in output\n\n### 2. Run tests without feature\n```bash\ncargo test\n```\nExpected: All existing tests pass, no GUI code compiled\n\n### 3. Check dependency tree\n```bash\n# Look for GUI deps\ncargo tree | grep -E \"winit|pixels|egui|wgpu\"\n```\nExpected: No output (no GUI deps)\n\n### 4. Compare binary sizes (optional)\n```bash\n# Build both versions\ncargo build --release\nls -la target/release/fractal_explorer\n\ncargo build --release --features gui\nls -la target/release/fractal_explorer\n```\nExpected: GUI version significantly larger\n\n### 5. Verify GUI code not compiled\n```bash\n# This should show the gui module files\nfind src -name \"*.rs\" -path \"*/gui/*\"\n\n# But they shouldn't be in the dep graph\ncargo tree --edges normal\n```\n\n### 6. Check for accidental imports\n```bash\n# Search for GUI imports outside of cfg blocks\ngrep -r \"use.*egui\" src/ --include=\"*.rs\" | grep -v \"#\\[cfg\"\ngrep -r \"use.*winit\" src/ --include=\"*.rs\" | grep -v \"#\\[cfg\"\ngrep -r \"use.*pixels\" src/ --include=\"*.rs\" | grep -v \"#\\[cfg\"\n```\nExpected: No matches (all GUI imports are inside cfg blocks)\n\n## Common Issues\n\n### Issue: GUI deps pulled in\n**Symptom**: `cargo tree` shows GUI crates without feature\n**Cause**: Missing `optional = true` or wrong feature wiring\n**Fix**: Check Cargo.toml feature definitions\n\n### Issue: Build fails without feature\n**Symptom**: Compile error referencing GUI types\n**Cause**: GUI type used outside `#[cfg(feature = \"gui\")]`\n**Fix**: Add proper cfg gating\n\n### Issue: Tests fail without feature\n**Symptom**: Test tries to use GUI functionality\n**Cause**: Test not properly gated\n**Fix**: Add `#[cfg(feature = \"gui\")]` to test\n\n## Success Criteria\n- [ ] `cargo build` succeeds without `--features gui`\n- [ ] `cargo test` succeeds without `--features gui`\n- [ ] No GUI deps in `cargo tree` output\n- [ ] All 87+ existing tests still pass\n- [ ] CLI functionality unchanged\n\n## Dependencies\n- All implementation tasks complete\n\n## Blocks\n- Task: Verify GUI binary functionality","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T13:35:49.077447496+08:00","created_by":"ren","updated_at":"2026-01-11T13:35:49.077447496+08:00","dependencies":[{"issue_id":"fractal_explorer-0gu","depends_on_id":"fractal_explorer-jo6","type":"blocks","created_at":"2026-01-11T13:37:26.061601837+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-0sv","title":"Add gui feature flag to Cargo.toml","description":"# Task: Add gui Feature Flag to Cargo.toml\n\n**Parent Epic**: Epic: Cargo Feature and Dependencies Setup\n\n## Objective\nAdd the `gui` feature flag to `Cargo.toml` that will gate all GUI functionality.\n\n## Implementation\n\n### 1. Add feature definition\n```toml\n[features]\ndefault = []\ngui = []  # Will add dependencies in next task\n```\n\n### 2. Add binary configuration\n```toml\n[[bin]]\nname = \"gui\"\npath = \"src/bin/gui.rs\"\nrequired-features = [\"gui\"]\n```\n\nThe `required-features` ensures helpful error message when running without feature:\n```\nerror: target `gui` in package `fractal_explorer` requires the features: `gui`\n```\n\n## Technical Notes\n\n### Feature Naming\nUsing `gui` rather than `interactive` or `window` because:\n- Clear and standard naming convention\n- Matches common Rust ecosystem patterns\n- Easy to remember and type\n\n### No Default GUI\nThe GUI feature is NOT in `default` because:\n- Library users may not want GUI deps\n- CLI-only usage should stay lightweight\n- Explicit opt-in is clearer\n\n## Success Criteria\n- [ ] `[features]` section exists with `gui` feature\n- [ ] `[[bin]]` section configured for gui binary\n- [ ] `cargo build` succeeds (no immediate errors)\n- [ ] `cargo run --bin gui` gives clear \"requires features\" error\n\n## Dependencies\n- Task: Research compatible GUI dependency versions (for version info)\n\n## Blocks\n- Task: Add GUI dependencies to Cargo.toml","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:31:55.22614749+08:00","created_by":"ren","updated_at":"2026-01-11T14:48:32.223081466+08:00","closed_at":"2026-01-11T14:48:32.223081466+08:00","close_reason":"Added gui feature flag and [[bin]] section to Cargo.toml. Created stub src/bin/gui.rs. All success criteria verified.","dependencies":[{"issue_id":"fractal_explorer-0sv","depends_on_id":"fractal_explorer-881","type":"blocks","created_at":"2026-01-11T13:37:13.303906084+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-23a","title":"Add feature-gated module declarations","description":"# Task: Add Feature-Gated Module Declarations\n\n**Parent Epic**: Epic: GUI Module Structure\n\n## Objective\nEnsure `#[cfg(feature = \"gui\")]` gates are correctly placed so GUI code is never compiled without the feature. Verify the gating works.\n\n## Background: Why Gate Declarations?\n\n### Wrong approach (gates only exports):\n```rust\n// In lib.rs - GUI code still compiles!\nmod input;  // Always compiles input module!\n#[cfg(feature = \"gui\")]\npub use input::gui::run_gui;\n```\nProblem: `input::gui` code still compiles even without feature.\n\n### Correct approach (gates declarations):\n```rust\n// In lib.rs - GUI code never compiles without feature\n#[cfg(feature = \"gui\")]\nmod input;\n\n#[cfg(feature = \"gui\")]\npub use input::gui::run_gui;\n```\nNow GUI code is only parsed/compiled when feature is enabled.\n\n## Implementation\n\n### 1. Verify src/lib.rs has correct gating\nAfter the module scaffold task, lib.rs should look like:\n```rust\nmod controllers;\nmod core;\n#[cfg(feature = \"gui\")]\nmod input;\nmod storage;\n\npub use controllers::mandelbrot::mandelbrot_controller;\n\n#[cfg(feature = \"gui\")]\npub use input::gui::run_gui;\n```\n\nKey points:\n- `mod input` is gated (not just the re-export)\n- The re-export is also gated (redundant but clear)\n\n### 2. Verify src/input/mod.rs has correct gating\n```rust\n//! Input adapters for the fractal explorer.\n\n#[cfg(feature = \"gui\")]\npub mod gui;\n```\n\nNote: Since the entire `input` module is already gated in lib.rs, this inner gate is technically redundant. However, it's good practice for when we might add non-GUI input adapters later.\n\n### 3. Verify gating works\n```bash\n# Should succeed without touching GUI code\ncargo build\necho $?  # Should be 0\n\n# Force recompile to ensure no caching issues\ncargo clean\ncargo build\n\n# Should compile GUI code\ncargo build --features gui\necho $?  # Should be 0\n```\n\n### 4. Verify with cargo-expand (optional)\nIf you want to see exactly what code is being compiled:\n```bash\ncargo install cargo-expand\ncargo expand --lib 2\u003e/dev/null | grep -A5 \"mod input\"\n# Should show nothing (module not present)\n\ncargo expand --lib --features gui 2\u003e/dev/null | grep -A5 \"mod input\"\n# Should show the input module\n```\n\n## Technical Notes\n\n### cfg_attr for conditional derives\nIf GUI types need derives only with feature:\n```rust\n#[cfg_attr(feature = \"gui\", derive(SomeGuiTrait))]\nstruct MyType;\n```\n\n### Feature in doc tests\nDoc examples using GUI code need feature annotation:\n```rust\n/// ```\n/// # #[cfg(feature = \"gui\")]\n/// fractal_explorer::run_gui();\n/// ```\n```\n\n### Why gate at multiple levels?\nWe gate at lib.rs level (`mod input`) for efficiency - the compiler won't even look at input/*.rs files.\nWe also gate inside input/mod.rs for clarity and future-proofing.\n\n## Success Criteria\n- [ ] `#[cfg(feature = \"gui\")]` on `mod input` in lib.rs\n- [ ] `#[cfg(feature = \"gui\")]` on `pub use input::gui::run_gui` in lib.rs  \n- [ ] `#[cfg(feature = \"gui\")]` on `pub mod gui` in input/mod.rs\n- [ ] `cargo build` succeeds without `--features gui`\n- [ ] `cargo build --features gui` succeeds\n- [ ] No GUI types leak into non-GUI code paths\n\n## Dependencies\n- Task: Create GUI module scaffold\n\n## Blocks\n- Task: Create binary entry point","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:32:38.285903977+08:00","created_by":"ren","updated_at":"2026-01-11T15:36:57.477902247+08:00","closed_at":"2026-01-11T15:36:57.477902247+08:00","close_reason":"Verified: cfg gating correctly placed in lib.rs and input/mod.rs. Both builds pass.","dependencies":[{"issue_id":"fractal_explorer-23a","depends_on_id":"fractal_explorer-nkj","type":"blocks","created_at":"2026-01-11T13:37:16.987326559+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-2qc","title":"Epic: GUI Module Structure","description":"# Epic: GUI Module Structure\n\n## Overview\nEstablish the module hierarchy for GUI code following the project's ports \u0026 adapters architecture. All GUI code lives under `src/input/gui/` as an input adapter.\n\n## Background \u0026 Rationale\n\n### Architectural Fit\nThe project uses hexagonal architecture (ports \u0026 adapters):\n- `core/` - Business logic and domain types (fractal algorithms, colour maps)\n- `controllers/` - Orchestration (coordinates actions, manages flow)\n- `input/` - Input adapters (CLI args, GUI events)\n- `storage/` - Output adapters (file writers)\n\nThe GUI is an **input adapter** because it:\n- Receives user input (mouse, keyboard, window events)\n- Produces `RenderRequest` commands for the controller\n- Does NOT contain business logic\n\n### Module Gating Strategy\nCritical: We must gate module **declarations**, not just exports.\n\n**Wrong approach:**\n```rust\n// In lib.rs - GUI code still compiles!\nmod input;\n#[cfg(feature = \"gui\")]\npub use input::gui::run_gui;\n```\n\n**Correct approach:**\n```rust\n// In lib.rs - GUI code never compiles without feature\n#[cfg(feature = \"gui\")]\npub mod gui;\n```\n\nOr within input/mod.rs:\n```rust\n#[cfg(feature = \"gui\")]\npub mod gui;\n```\n\nThis ensures non-GUI builds don't waste time compiling GUI code and don't need GUI dependencies installed.\n\n## Module Layout\n```\nsrc/\n├── input/\n│   ├── mod.rs          # Declares gui submodule (gated)\n│   └── gui/\n│       ├── mod.rs      # Exports run_gui(), internal modules\n│       └── app.rs      # winit event loop, pixels, egui integration\n├── bin/\n│   └── gui.rs          # Binary entry point (required-features)\n└── lib.rs              # Gates input::gui module\n```\n\n## Technical Considerations\n\n### Binary Configuration\n```toml\n[[bin]]\nname = \"gui\"\npath = \"src/bin/gui.rs\"\nrequired-features = [\"gui\"]\n```\n\nThe `required-features` ensures `cargo run --bin gui` fails helpfully without the feature, rather than with cryptic compile errors.\n\n### Re-export Pattern\nThe binary should be minimal:\n```rust\nfn main() {\n    fractal_explorer::input::gui::run_gui();\n}\n```\n\nAll logic lives in the library for testability.\n\n## Success Criteria\n- [ ] `src/input/gui/mod.rs` exists and exports `run_gui()`\n- [ ] `src/input/gui/app.rs` exists (can be stub initially)\n- [ ] `src/bin/gui.rs` exists with `required-features`\n- [ ] `#[cfg(feature = \"gui\")]` gates all GUI module declarations\n- [ ] `cargo build` without feature doesn't touch GUI code\n\n## Dependencies\n- Epic: Cargo Feature and Dependencies Setup\n\n## Blocks\n- Epic: Window and Event Loop\n- Epic: Pixels Rendering Pipeline\n- Epic: Egui Overlay Integration","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T13:30:18.61726829+08:00","created_by":"ren","updated_at":"2026-01-11T15:43:28.846445042+08:00","closed_at":"2026-01-11T15:43:28.846445042+08:00","close_reason":"Epic complete. All module structure in place: gui module scaffold, feature gating, and binary entry point.","dependencies":[{"issue_id":"fractal_explorer-2qc","depends_on_id":"fractal_explorer-kjc","type":"blocks","created_at":"2026-01-11T13:36:31.074986491+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-3dm","title":"Epic: Window and Event Loop","description":"# Epic: Window and Event Loop\n\n## Overview\nImplement the winit-based event loop that creates a window and handles system events. This is the runtime foundation for the GUI - everything else (pixels rendering, egui UI) plugs into this loop.\n\n## Background \u0026 Rationale\n\n### Why winit?\nwinit is the de-facto standard for cross-platform windowing in Rust:\n- Abstracts platform differences (Windows, macOS, Linux/Wayland/X11)\n- Provides the event loop that drives the application\n- Handles window creation, resize, DPI, input events\n- Used by most Rust GUI/game projects\n\n### Event Loop Model\nwinit uses an event-driven model:\n```rust\nevent_loop.run(|event, elwt| {\n    match event {\n        Event::WindowEvent { event, .. } =\u003e { ... }\n        Event::AboutToWait =\u003e { ... }\n        _ =\u003e {}\n    }\n});\n```\n\nKey events we must handle:\n- `CloseRequested` - User clicked X, clean shutdown\n- `Resized` - Window size changed, must resize pixels surface\n- `ScaleFactorChanged` - DPI changed (monitor switch, settings change)\n- `RedrawRequested` - Time to render a frame\n\n### Redraw Strategy (Important!)\nWe must NOT busy-loop rendering. Instead:\n1. Render only on `RedrawRequested`\n2. Call `window.request_redraw()` when state changes (input, resize)\n3. Request initial redraw after setup so first frame appears\n\nThis keeps CPU usage low when idle while remaining responsive.\n\n### Threading Constraint\n**Critical**: winit's event loop must run on the main thread. On macOS, this is enforced by the OS. The window, pixels surface, and wgpu objects must all be used from this thread.\n\nIn later milestones, fractal computation will happen on worker threads, but they'll only produce data and signal the UI thread - never touch window/GPU objects directly.\n\n## Technical Considerations\n\n### Window Configuration\n```rust\nlet window = WindowBuilder::new()\n    .with_title(\"Fractal Explorer\")\n    .with_inner_size(LogicalSize::new(800, 600))\n    .with_min_inner_size(LogicalSize::new(200, 200))\n    .build(\u0026event_loop)?;\n```\n\nUsing `LogicalSize` for initial size lets winit handle DPI scaling. We'll use physical size for the actual pixel buffer.\n\n### Physical vs Logical Size\n- **Logical size**: What the user thinks of as \"window size\" (e.g., 800x600)\n- **Physical size**: Actual pixels (e.g., 1600x1200 on 2x DPI display)\n- `pixels` surface uses physical size\n- egui needs scale factor for proper text rendering\n\n### Graceful Resize\nWhen resizing rapidly, we may get many resize events. Best practice:\n- Update surface size immediately (prevents crashes)\n- Don't re-render on every resize event (coalesce via redraw request)\n- Handle 0x0 size gracefully (minimized window)\n\n## Success Criteria\n- [ ] Window opens with title \"Fractal Explorer\"\n- [ ] Window is resizable with reasonable minimum size\n- [ ] Close button works (clean exit, no panic)\n- [ ] Resize events are handled without crashes\n- [ ] Application doesn't busy-loop (low CPU when idle)\n- [ ] First frame appears without user interaction\n\n## Dependencies\n- Epic: GUI Module Structure\n\n## Blocks\n- Epic: Pixels Rendering Pipeline","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-11T13:30:18.722577837+08:00","created_by":"ren","updated_at":"2026-01-11T13:30:18.722577837+08:00","dependencies":[{"issue_id":"fractal_explorer-3dm","depends_on_id":"fractal_explorer-2qc","type":"blocks","created_at":"2026-01-11T13:36:36.502920198+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-3j7","title":"Handle pixels resize and edge cases","description":"# Task: Handle pixels Resize and Edge Cases\n\n**Parent Epic**: Epic: Pixels Rendering Pipeline\n\n## Objective\nProperly handle window resize by updating both the pixels surface and frame buffer. Handle edge cases like minimized windows (0x0 size).\n\n## Implementation\n\n### 1. Resize handler\n```rust\nfn resize(\u0026mut self, width: u32, height: u32) {\n    // Skip invalid sizes\n    if width == 0 || height == 0 {\n        return;\n    }\n    \n    self.width = width;\n    self.height = height;\n    \n    // Resize the GPU surface (window backing store)\n    if let Err(e) = self.pixels.resize_surface(width, height) {\n        eprintln!(\"Failed to resize surface: {e}\");\n        return;\n    }\n    \n    // Resize the pixel buffer (our drawing target)\n    if let Err(e) = self.pixels.resize_buffer(width, height) {\n        eprintln!(\"Failed to resize buffer: {e}\");\n        return;\n    }\n}\n```\n\n### 2. Wire to window event\n```rust\nWindowEvent::Resized(physical_size) =\u003e {\n    app.resize(physical_size.width, physical_size.height);\n    window.request_redraw();\n}\n```\n\n### 3. Handle 0x0 in render\n```rust\nfn render(\u0026mut self) -\u003e Result\u003c(), pixels::Error\u003e {\n    if self.width == 0 || self.height == 0 {\n        return Ok(()); // Skip rendering for invalid size\n    }\n    \n    self.draw_placeholder();\n    self.pixels.render()\n}\n```\n\n### 4. Scale factor handling\n```rust\nWindowEvent::ScaleFactorChanged { scale_factor, .. } =\u003e {\n    self.scale_factor = scale_factor as f32;\n    // Get new physical size\n    let size = window.inner_size();\n    app.resize(size.width, size.height);\n    window.request_redraw();\n}\n```\n\n## Technical Notes\n\n### Why two resize calls?\n- `resize_surface()`: Updates the wgpu surface attached to the window\n- `resize_buffer()`: Updates the pixel buffer we draw to\n\nBoth must be called for correct rendering. If only surface is resized, content will be scaled/stretched incorrectly.\n\n### Resize during resize\nUsers may drag the window edge continuously, generating many resize events. The pattern should:\n1. Update dimensions immediately (so next render uses correct size)\n2. Request redraw (coalesces multiple events)\n3. Actual render happens on RedrawRequested (after all events processed)\n\n### Minimized windows\n- Windows: 0x0 when minimized\n- macOS: May report previous size\n- Linux: Varies by compositor\n\nAlways check for 0x0 and skip rendering.\n\n### Memory allocation\n`resize_buffer()` may allocate new memory. For very large windows, this could fail. Current approach panics; production might cap size or show error.\n\n## Success Criteria\n- [ ] Resize updates both surface and buffer\n- [ ] Pattern fills entire window after resize\n- [ ] Minimizing doesn't crash\n- [ ] Restoring from minimize shows correct content\n- [ ] Rapid resize dragging works smoothly\n- [ ] Scale factor changes handled (move to different DPI monitor)\n\n## Dependencies\n- Task: Initialize pixels surface\n- Task: Implement placeholder pattern rendering\n\n## Blocks\n- Epic: Egui Overlay Integration","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:34:16.327847057+08:00","created_by":"ren","updated_at":"2026-01-11T20:56:24.580257831+08:00","closed_at":"2026-01-11T20:56:24.580257831+08:00","close_reason":"Implemented scale factor changes, focused events, and 0x0 size guard","dependencies":[{"issue_id":"fractal_explorer-3j7","depends_on_id":"fractal_explorer-knj","type":"blocks","created_at":"2026-01-11T13:37:21.269972134+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-4x0","title":"Epic: Pixels Rendering Pipeline","description":"# Epic: Pixels Rendering Pipeline\n\n## Overview\nIntegrate the `pixels` crate to render a software framebuffer to the window. This establishes the rendering pipeline that will later display fractal images.\n\n## Background \u0026 Rationale\n\n### Why pixels?\nThe `pixels` crate provides:\n- Simple software rendering (write to a `\u0026mut [u8]` buffer)\n- Efficient upload to GPU via wgpu\n- Automatic scaling to window size\n- Hook for custom render passes (needed for egui)\n\nThis matches our architecture: core fractal code produces RGB pixel data, and we need a simple way to display it. `pixels` handles all the GPU complexity.\n\n### How pixels Works\n```rust\n// Create surface tied to window\nlet pixels = Pixels::new(width, height, surface_texture)?;\n\n// Each frame:\nlet frame = pixels.frame_mut(); // \u0026mut [u8], RGBA format\n// Fill frame with pixel data...\npixels.render()?; // Upload to GPU and present\n```\n\nThe frame buffer is separate from the window size - `pixels` scales appropriately.\n\n### Buffer vs Surface Size\nTwo distinct concepts:\n- **Buffer size**: Resolution of our rendered image (e.g., 800x600)\n- **Surface size**: Physical window size in pixels\n\nInitially, we'll keep these the same. Later milestones may render at lower resolution for performance (render-scale slider).\n\n## Technical Considerations\n\n### RGBA Format\n`pixels` uses RGBA (4 bytes per pixel), but our fractal renderer produces RGB (3 bytes). We'll need conversion:\n```rust\n// RGB to RGBA\nfor (i, pixel) in frame.chunks_exact_mut(4).enumerate() {\n    let rgb = \u0026source_rgb[i * 3..i * 3 + 3];\n    pixel[0] = rgb[0]; // R\n    pixel[1] = rgb[1]; // G\n    pixel[2] = rgb[2]; // B\n    pixel[3] = 255;    // A (opaque)\n}\n```\n\nFor the placeholder, we can write RGBA directly.\n\n### Placeholder Pattern\nA simple gradient or checkerboard proves the pipeline works:\n```rust\nfor (i, pixel) in frame.chunks_exact_mut(4).enumerate() {\n    let x = (i % width) as u8;\n    let y = (i / width) as u8;\n    pixel[0] = x;           // R varies with x\n    pixel[1] = y;           // G varies with y\n    pixel[2] = 128;         // B constant\n    pixel[3] = 255;         // A opaque\n}\n```\n\n### Resize Handling\nOn window resize:\n1. `pixels.resize_surface(new_width, new_height)` - Updates wgpu surface\n2. `pixels.resize_buffer(new_width, new_height)` - Updates frame buffer\n\nBoth are needed. Skip if size is 0x0 (minimized window).\n\n### Error Handling\n`pixels.render()` can fail (lost GPU device, surface error). For now, a simple retry or exit is fine. Production code might recreate the surface.\n\n## Success Criteria\n- [ ] pixels surface initializes successfully\n- [ ] Placeholder pattern renders to window\n- [ ] Resize updates both surface and buffer\n- [ ] Minimizing to 0x0 doesn't crash\n- [ ] Restoring from minimized shows correct content\n- [ ] No visual artifacts or tearing\n\n## Dependencies\n- Epic: Window and Event Loop\n\n## Blocks\n- Epic: Egui Overlay Integration","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-11T13:30:18.842597779+08:00","created_by":"ren","updated_at":"2026-01-11T13:30:18.842597779+08:00","dependencies":[{"issue_id":"fractal_explorer-4x0","depends_on_id":"fractal_explorer-3dm","type":"blocks","created_at":"2026-01-11T13:36:36.582577158+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-51g","title":"Epic: Egui Overlay Integration","description":"# Epic: Egui Overlay Integration\n\n## Overview\nIntegrate egui (immediate-mode GUI) to render UI controls overlaid on the pixels framebuffer. This provides the foundation for all future UI: parameter sliders, algorithm selection, status displays.\n\n## Background \u0026 Rationale\n\n### Why egui?\negui is ideal for this project:\n- **Immediate mode**: No retained widget state to sync with app state\n- **Rust-native**: Integrates naturally with Rust code\n- **Lightweight**: Minimal dependencies, fast compile\n- **GPU-rendered**: Uses wgpu, can share device with pixels\n\n### Immediate Mode Concept\nTraditional GUI: Create widgets, wire callbacks, update on events\nImmediate mode: Every frame, declare what UI should exist\n```rust\negui::Window::new(\"Controls\").show(ctx, |ui| {\n    ui.label(\"Max iterations:\");\n    ui.add(egui::Slider::new(\u0026mut self.max_iter, 10..=1000));\n});\n```\n\nThe slider is \"created\" every frame but egui handles the illusion of persistence. State lives in your app, not in widgets.\n\n### Integration Architecture\n```\n┌─────────────────────────────────────────┐\n│ winit event loop                        │\n│   │                                     │\n│   ├─► egui-winit: converts events       │\n│   │                                     │\n│   ▼                                     │\n│ egui context: builds UI                 │\n│   │                                     │\n│   ▼                                     │\n│ pixels.render_with(): custom pass       │\n│   │                                     │\n│   ├─► pixels: renders framebuffer       │\n│   └─► egui-wgpu: renders UI on top      │\n│                                         │\n└─────────────────────────────────────────┘\n```\n\n### Key Insight: pixels::render_with()\n`pixels` provides a hook for custom render passes:\n```rust\npixels.render_with(|encoder, render_target, context| {\n    // context.device, context.queue available\n    // Render egui here, after pixels has drawn\n})?;\n```\n\nThis lets us share the wgpu device/queue rather than creating a second one (which would fail or be wasteful).\n\n## Technical Considerations\n\n### Event Flow\n1. winit produces events\n2. egui-winit translates to egui's RawInput\n3. egui processes input, determines what's hovered/focused\n4. egui returns whether it \"consumed\" the event\n\nWe must check if egui consumed events to avoid passing clicks \"through\" UI to the fractal (in later milestones).\n\n### Scale Factor\negui needs the scale factor for proper text rendering:\n```rust\nlet ctx = egui::Context::default();\nctx.set_pixels_per_point(window.scale_factor() as f32);\n```\n\nUpdate this on `ScaleFactorChanged` events.\n\n### TextureFormat Matching\negui-wgpu needs to render to the same format as the pixels surface. Get this from the SurfaceTexture:\n```rust\nlet texture_format = pixels.render_texture_format();\n```\n\n### Minimal Panel (This Milestone)\nFor now, just prove integration works:\n```rust\negui::Window::new(\"Debug\").show(ctx, |ui| {\n    ui.label(\"Fractal Explorer\");\n    ui.add(egui::Slider::new(\u0026mut self.test_value, 0.0..=1.0).text(\"Test\"));\n});\n```\n\nFuture milestones will add real controls.\n\n## Success Criteria\n- [ ] egui context initializes correctly\n- [ ] egui receives window events via egui-winit\n- [ ] egui panel renders on top of pixels framebuffer\n- [ ] UI text is crisp (correct scale factor)\n- [ ] Slider widget is interactive (value changes)\n- [ ] UI doesn't flicker or have z-fighting with pixels\n\n## Dependencies\n- Epic: Pixels Rendering Pipeline\n\n## Blocks\n- Epic: Build Verification","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-11T13:30:18.962861886+08:00","created_by":"ren","updated_at":"2026-01-11T13:30:18.962861886+08:00","dependencies":[{"issue_id":"fractal_explorer-51g","depends_on_id":"fractal_explorer-4x0","type":"blocks","created_at":"2026-01-11T13:36:36.664521898+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-881","title":"Research compatible GUI dependency versions","description":"# Task: Research Compatible GUI Dependency Versions\n\n**Parent Epic**: Epic: Cargo Feature and Dependencies Setup\n\n## Research Complete - Version Matrix\n\n### Verified Compatible Versions\n```toml\npixels = \"0.15\"\nwinit = \"0.29\"\negui = \"0.26\"\negui-winit = \"0.26\"\negui-wgpu = \"0.26\"\n```\n\n### Underlying Dependencies\n- **wgpu**: 0.19 (used by pixels 0.15, egui-wgpu 0.26)\n- **winit**: 0.29 (used by pixels 0.15, egui-winit 0.26)\n- **raw-window-handle**: 0.6\n\n### Verification Results\n- `cargo build` succeeds (without gui feature)\n- `cargo build --features gui` succeeds\n- `cargo tree` shows no GUI deps without feature flag\n- All 94 tests pass\n\n### Important Notes\n\n1. **Latest egui is incompatible**: egui 0.33+ uses wgpu 27 and winit 0.30, which conflicts with pixels 0.15\n\n2. **Reference example**: The pixels repo has a `minimal-egui` example at `examples/minimal-egui/` using these exact versions\n\n3. **Feature flag syntax**: Use `dep:` syntax (Rust 1.60+) for cleaner optional dependencies:\n   ```toml\n   [features]\n   gui = [\"dep:winit\", \"dep:pixels\", \"dep:egui\", \"dep:egui-winit\", \"dep:egui-wgpu\"]\n   ```\n\n4. **winit 0.29 API**: This version uses the older event loop API (not the 0.30+ redesign), which is well-documented in pixels examples\n\n### Useful Resources\n- pixels docs: https://docs.rs/pixels/0.15.0\n- pixels minimal-egui example: https://github.com/parasyte/pixels/tree/main/examples/minimal-egui\n- egui-wgpu 0.26 docs: https://docs.rs/egui-wgpu/0.26.0\n- egui-winit 0.26 docs: https://docs.rs/egui-winit/0.26.0\n\n---\n\n## Original Task Description\n\n### Objective\nDetermine the exact versions of `pixels`, `winit`, `egui`, `egui-winit`, and `egui-wgpu` that are mutually compatible. Document findings for use in subsequent tasks.\n\n### Background\nThe GUI stack has interdependencies:\n- `pixels` bundles a specific `wgpu` version\n- `egui-wgpu` must use the same `wgpu` major version\n- `egui-winit` must match the `winit` version used by `pixels`\n- Mismatches cause compile errors or runtime panics","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:31:55.133787471+08:00","created_by":"ren","updated_at":"2026-01-11T14:37:45.94318657+08:00","closed_at":"2026-01-11T14:37:45.94318657+08:00","close_reason":"Research complete - verified compatible versions: pixels 0.15, winit 0.29, egui/egui-winit/egui-wgpu 0.26"}
{"id":"fractal_explorer-a13","title":"Create binary entry point (gui.rs)","description":"# Task: Create Binary Entry Point (gui.rs)\n\n**Parent Epic**: Epic: GUI Module Structure\n\n## Objective\nCreate `src/bin/gui.rs` that serves as the entry point for the GUI application.\n\n## Implementation\n\n### 1. Create src/bin/gui.rs\n```rust\n//! GUI binary for interactive fractal exploration.\n//!\n//! Run with: cargo run --features gui --bin gui\n\nfn main() {\n    fractal_explorer::input::gui::run_gui();\n}\n```\n\nOr if re-exported at crate root:\n```rust\nfn main() {\n    fractal_explorer::run_gui();\n}\n```\n\n### 2. Verify Cargo.toml configuration\nEnsure this exists (from earlier task):\n```toml\n[[bin]]\nname = \"gui\"\npath = \"src/bin/gui.rs\"\nrequired-features = [\"gui\"]\n```\n\n### 3. Test the binary\n```bash\n# Without feature - should give clear error\ncargo run --bin gui\n# Expected: \"requires the features: `gui`\"\n\n# With feature - should run (and panic on todo!())\ncargo run --features gui --bin gui\n# Expected: panic with \"not yet implemented: Implement GUI event loop\"\n```\n\n## Technical Notes\n\n### Keep main() minimal\nThe binary should only call into library code:\n- Easier to test (library functions can be unit tested)\n- Cleaner separation of concerns\n- Binary is just the entry point\n\n### Error handling\nFor now, let panics propagate. Later, consider:\n```rust\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    fractal_explorer::run_gui()?;\n    Ok(())\n}\n```\n\n### Future: CLI arguments\nLater milestones might add arguments:\n```rust\nfn main() {\n    let args = Args::parse();\n    fractal_explorer::run_gui(args.into());\n}\n```\n\nFor now, no arguments needed.\n\n## Success Criteria\n- [ ] `src/bin/gui.rs` exists\n- [ ] Calls `run_gui()` from library\n- [ ] `cargo run --bin gui` shows feature requirement error\n- [ ] `cargo run --features gui --bin gui` runs (panics on todo is OK)\n\n## Dependencies\n- Task: Create GUI module scaffold\n- Task: Add feature-gated module declarations\n\n## Blocks\n- Epic: Window and Event Loop","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:32:40.780952979+08:00","created_by":"ren","updated_at":"2026-01-11T15:42:55.492530204+08:00","closed_at":"2026-01-11T15:42:55.492530204+08:00","close_reason":"Binary entry point implemented. Calls run_gui() from library. Both build modes verified.","dependencies":[{"issue_id":"fractal_explorer-a13","depends_on_id":"fractal_explorer-23a","type":"blocks","created_at":"2026-01-11T13:37:17.02277256+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-ahl","title":"Verify GUI binary functionality","description":"# Task: Verify GUI Binary Functionality\n\n**Parent Epic**: Epic: Build Verification and Testing\n\n## Objective\nConfirm the GUI binary compiles and runs correctly with the expected functionality.\n\n## Verification Steps\n\n### 1. Build with GUI feature\n```bash\ncargo build --features gui\n```\nExpected: Success, compiles winit/pixels/egui\n\n### 2. Check GUI deps present\n```bash\ncargo tree --features gui | grep -E \"winit|pixels|egui\"\n```\nExpected: Shows GUI dependency tree\n\n### 3. Run the binary\n```bash\ncargo run --features gui --bin gui\n```\nExpected: Window opens\n\n### 4. Visual verification (manual)\n- [ ] Window titled \"Fractal Explorer\"\n- [ ] Window is approximately 800x600 initially\n- [ ] Placeholder pattern visible (gradient or checkerboard)\n- [ ] egui panel visible in top-left\n- [ ] Panel shows \"Fractal Explorer\" heading\n- [ ] Slider is present and interactive\n- [ ] Window size label shows correct dimensions\n\n### 5. Interaction tests (manual)\n- [ ] Drag slider → value changes\n- [ ] Drag egui panel → panel moves\n- [ ] Click outside panel → doesn't affect panel\n- [ ] Resize window → pattern and panel adjust\n- [ ] Minimize window → no crash\n- [ ] Restore window → content reappears\n- [ ] Close window → clean exit (no panic in terminal)\n\n### 6. DPI test (if available)\n- [ ] Move window to different DPI monitor\n- [ ] Text remains crisp\n- [ ] Content scales appropriately\n\n### 7. Stress test\n```bash\n# Run for extended period\ncargo run --features gui --bin gui \u0026\nsleep 60\n# Check CPU usage isn't pegged (should be idle when not interacting)\n# Kill with Ctrl+C in window\n```\n\n## Common Issues\n\n### Issue: Window doesn't open\n**Symptom**: Binary runs but no window\n**Cause**: Event loop not started, or window created but not shown\n**Fix**: Check event_loop.run() is called\n\n### Issue: Black window\n**Symptom**: Window opens but content is black\n**Cause**: pixels.render() not called, or frame not filled\n**Fix**: Verify render path\n\n### Issue: egui not visible\n**Symptom**: Placeholder shows but no UI\n**Cause**: egui render pass not executing\n**Fix**: Check render_with() callback\n\n### Issue: High CPU usage\n**Symptom**: 100% CPU when idle\n**Cause**: Busy-loop rendering instead of on-demand\n**Fix**: Only render on RedrawRequested\n\n### Issue: Crash on resize\n**Symptom**: Panic when resizing rapidly\n**Cause**: 0x0 size not handled, or resize race condition\n**Fix**: Add size validation\n\n## Success Criteria\n- [ ] Binary compiles with `--features gui`\n- [ ] Binary runs without crash\n- [ ] All visual verification items pass\n- [ ] All interaction tests pass\n- [ ] CPU idle when not interacting\n- [ ] No panics or errors in terminal output\n\n## Dependencies\n- Task: Verify non-GUI build isolation\n- All implementation tasks complete\n\n## Blocks\n- Task: Create manual testing checklist","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T13:36:01.234823293+08:00","created_by":"ren","updated_at":"2026-01-11T13:36:01.234823293+08:00","dependencies":[{"issue_id":"fractal_explorer-ahl","depends_on_id":"fractal_explorer-0gu","type":"blocks","created_at":"2026-01-11T13:37:26.083565197+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-aue","title":"Handle window lifecycle events","description":"# Task: Handle Window Lifecycle Events\n\n**Parent Epic**: Epic: Window and Event Loop\n\n## Objective\nHandle resize, scale factor changes, and other window lifecycle events properly. This is critical for robust operation across different displays and user interactions.\n\n## Implementation\n\n### 1. Resize handling\n```rust\nWindowEvent::Resized(physical_size) =\u003e {\n    let width = physical_size.width;\n    let height = physical_size.height;\n    \n    if width \u003e 0 \u0026\u0026 height \u003e 0 {\n        // Store new size for pixels resize (next task)\n        self.width = width;\n        self.height = height;\n        // Will call pixels.resize_surface() and pixels.resize_buffer()\n    }\n    // Skip 0x0 (minimized window)\n}\n```\n\n### 2. Scale factor changes\n```rust\nWindowEvent::ScaleFactorChanged { scale_factor, .. } =\u003e {\n    // Update scale factor for egui text rendering\n    self.scale_factor = scale_factor;\n    \n    // Note: In winit 0.29+, new_inner_size is not provided here\n    // Get updated size from window.inner_size() in next frame\n}\n```\n\n### 3. Focus events (optional but nice)\n```rust\nWindowEvent::Focused(focused) =\u003e {\n    // Could reduce render rate when unfocused\n    self.focused = focused;\n}\n```\n\n### 4. Redraw requests\n```rust\nWindowEvent::RedrawRequested =\u003e {\n    // Render the frame\n    self.render();\n    \n    // For continuous animation, request another:\n    // window.request_redraw();\n    // But we want on-demand rendering, so don't auto-request\n}\n```\n\n## Technical Notes\n\n### Physical vs Logical Size\n- `Resized` event provides **physical** size (actual pixels)\n- Use physical size for pixels surface/buffer\n- Use logical size (physical / scale_factor) for UI layout\n\n### Handling 0x0 Size\nWindows can be minimized to 0x0. Rendering to 0x0:\n- May cause panics in some backends\n- Wastes CPU cycles\n- Skip rendering entirely when size is 0x0\n\n```rust\nif self.width == 0 || self.height == 0 {\n    return; // Skip render\n}\n```\n\n### Scale Factor\n- 1.0 = standard DPI (96 DPI on Windows, 72 on macOS historically)\n- 2.0 = \"Retina\" / HiDPI\n- Can be fractional (1.25, 1.5, etc.)\n\negui needs this for crisp text rendering.\n\n### Event Ordering\nEvents may come in batches. Don't render on every event - wait for `RedrawRequested` which comes after event processing.\n\n## Success Criteria\n- [ ] Resize updates stored dimensions\n- [ ] 0x0 size is handled gracefully (no crash)\n- [ ] Scale factor changes are captured\n- [ ] No rendering during resize spam (coalesced)\n- [ ] Application remains responsive during resize\n\n## Dependencies\n- Task: Implement winit event loop skeleton\n\n## Blocks\n- Epic: Pixels Rendering Pipeline","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:34:11.455998666+08:00","created_by":"ren","updated_at":"2026-01-11T20:56:24.563887475+08:00","closed_at":"2026-01-11T20:56:24.563887475+08:00","close_reason":"Implemented scale factor changes, focused events, and 0x0 size guard","dependencies":[{"issue_id":"fractal_explorer-aue","depends_on_id":"fractal_explorer-y8r","type":"blocks","created_at":"2026-01-11T13:37:19.393860446+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-j4n","title":"Set up egui context and input handling","description":"# Task: Set up egui Context and Input Handling\n\n**Parent Epic**: Epic: Egui Overlay Integration\n\n## Objective\nInitialize egui and wire it to receive window events via egui-winit. This enables egui to track mouse position, clicks, keyboard input, and other interactions.\n\n## Implementation\n\n### 1. Create egui context and state\n```rust\nuse egui::Context;\nuse egui_winit::State as EguiWinitState;\n\nstruct App {\n    // ... existing fields ...\n    egui_ctx: Context,\n    egui_state: EguiWinitState,\n}\n\nimpl App {\n    fn new(window: \u0026Window, event_loop: \u0026EventLoop\u003c()\u003e) -\u003e Self {\n        let egui_ctx = Context::default();\n        let egui_state = EguiWinitState::new(\n            egui_ctx.clone(),\n            egui_ctx.viewport_id(),\n            \u0026event_loop,\n            Some(window.scale_factor() as f32),\n            None, // max_texture_side, use default\n        );\n        \n        // ... rest of initialization ...\n    }\n}\n```\n\n### 2. Forward events to egui\n```rust\n// In event handler:\nEvent::WindowEvent { event, window_id } if window_id == window.id() =\u003e {\n    // Let egui process the event first\n    let response = app.egui_state.on_window_event(\u0026window, \u0026event);\n    \n    if response.consumed {\n        // egui handled it (e.g., click on UI element)\n        return;\n    }\n    \n    // Handle event ourselves if egui didn't consume it\n    match event {\n        WindowEvent::CloseRequested =\u003e { ... }\n        // ...\n    }\n}\n```\n\n### 3. Update scale factor\n```rust\nWindowEvent::ScaleFactorChanged { scale_factor, .. } =\u003e {\n    app.egui_ctx.set_pixels_per_point(scale_factor as f32);\n    // ... rest of scale factor handling ...\n}\n```\n\n### 4. Begin/end frame pattern\n```rust\nfn update_ui(\u0026mut self, window: \u0026Window) -\u003e egui::FullOutput {\n    let raw_input = self.egui_state.take_egui_input(\u0026window);\n    \n    self.egui_ctx.run(raw_input, |ctx| {\n        // Define UI here (next task)\n        egui::Window::new(\"Debug\").show(ctx, |ui| {\n            ui.label(\"Hello\");\n        });\n    })\n}\n```\n\n## Technical Notes\n\n### egui-winit version compatibility\negui-winit API changes between versions. The above is for recent versions (0.25+). Check actual version and adjust:\n- Constructor arguments may differ\n- `on_window_event` signature may vary\n\n### Event consumption\n`response.consumed` tells us if egui \"used\" the event:\n- Click inside egui panel → consumed\n- Click outside → not consumed (pass to our app)\n\nImportant for pan/zoom in later milestones.\n\n### Context cloning\n`egui::Context` uses `Arc` internally, so cloning is cheap and shares state.\n\n### Repaint requests\negui may request repaints (animations, cursor blink):\n```rust\nif response.repaint_after.is_zero() {\n    window.request_redraw();\n}\n```\n\n## Success Criteria\n- [ ] egui context initializes without error\n- [ ] egui-winit state created with correct scale factor\n- [ ] Window events forwarded to egui\n- [ ] egui reports consumed/not consumed correctly\n- [ ] Mouse cursor position tracked by egui\n- [ ] No crashes on rapid input\n\n## Dependencies\n- Task: Handle pixels resize and edge cases\n- Epic: Cargo Feature and Dependencies Setup (needs egui deps)\n\n## Blocks\n- Task: Integrate egui rendering with pixels\n- Task: Create minimal UI panel","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T13:34:17.967017073+08:00","created_by":"ren","updated_at":"2026-01-11T13:34:17.967017073+08:00","dependencies":[{"issue_id":"fractal_explorer-j4n","depends_on_id":"fractal_explorer-3j7","type":"blocks","created_at":"2026-01-11T13:37:23.218418192+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-jo6","title":"Create minimal UI panel","description":"# Task: Create Minimal UI Panel\n\n**Parent Epic**: Epic: Egui Overlay Integration\n\n## Objective\nCreate a simple egui panel with a label and interactive slider to prove the UI integration works end-to-end. This is the \"hello world\" of our GUI system.\n\n## Implementation\n\n### 1. Add UI state\n```rust\nstruct App {\n    // ... existing fields ...\n    \n    // UI state\n    test_slider_value: f32,\n}\n```\n\n### 2. Define UI in update_ui()\n```rust\nfn update_ui(\u0026mut self, window: \u0026Window) -\u003e egui::FullOutput {\n    let raw_input = self.egui_state.take_egui_input(window);\n    \n    self.egui_ctx.run(raw_input, |ctx| {\n        egui::Window::new(\"Debug Panel\")\n            .default_pos([10.0, 10.0])\n            .default_size([200.0, 100.0])\n            .show(ctx, |ui| {\n                ui.heading(\"Fractal Explorer\");\n                ui.separator();\n                \n                ui.label(\"Test slider:\");\n                ui.add(egui::Slider::new(\u0026mut self.test_slider_value, 0.0..=1.0)\n                    .text(\"value\"));\n                \n                ui.separator();\n                ui.label(format!(\"Window size: {}x{}\", self.width, self.height));\n            });\n    })\n}\n```\n\n### 3. Optional: Use slider value\nTo prove interactivity, could affect the placeholder:\n```rust\nfn draw_placeholder(\u0026mut self) {\n    let intensity = (self.test_slider_value * 255.0) as u8;\n    \n    for pixel in self.pixels.frame_mut().chunks_exact_mut(4) {\n        pixel[0] = intensity;  // R controlled by slider\n        pixel[1] = 100;        // G\n        pixel[2] = 150;        // B\n        pixel[3] = 255;        // A\n    }\n}\n```\n\n## Technical Notes\n\n### egui Window vs window\n- `egui::Window`: A draggable panel within the egui UI\n- `winit::Window`: The OS-level window\n\nDon't confuse them. egui::Window is just a UI container.\n\n### Default position\n`default_pos` sets initial position (in logical pixels from top-left). User can drag to move. Position is remembered per-window-name by egui.\n\n### Slider range\n`0.0..=1.0` is the range. The `..=` is inclusive end. For integers, use `0..=100` etc.\n\n### Label formatting\negui labels can use `format!()` for dynamic content. Updated every frame automatically (immediate mode advantage).\n\n### Panel transparency\negui panels have semi-transparent backgrounds by default, allowing the fractal (placeholder for now) to show through slightly. This is configurable via egui style.\n\n## Success Criteria\n- [ ] Panel appears at startup\n- [ ] \"Fractal Explorer\" heading visible\n- [ ] Slider is visible and draggable\n- [ ] Slider value changes when dragged\n- [ ] Window size label updates on resize\n- [ ] Panel is draggable (can reposition)\n- [ ] Panel doesn't interfere with window close button\n\n## Dependencies\n- Task: Set up egui context and input handling\n- Task: Integrate egui rendering with pixels\n\n## Blocks\n- Epic: Build Verification and Testing","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T13:35:48.038399582+08:00","created_by":"ren","updated_at":"2026-01-11T13:35:48.038399582+08:00","dependencies":[{"issue_id":"fractal_explorer-jo6","depends_on_id":"fractal_explorer-tfa","type":"blocks","created_at":"2026-01-11T13:37:23.28210637+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-kjc","title":"Epic: Cargo Feature and Dependencies Setup","description":"# Epic: Cargo Feature and Dependencies Setup\n\n## Overview\nEstablish the Cargo.toml configuration for feature-gated GUI support. This is the foundation that enables all subsequent GUI work while preserving the lightweight nature of non-GUI builds.\n\n## Background \u0026 Rationale\nThe fractal_explorer project uses a ports \u0026 adapters architecture. The GUI is an input adapter that should be completely optional. Users who only want the CLI/library functionality should not pay the cost of compiling or linking GUI dependencies (winit, pixels, egui, wgpu).\n\nRust's feature flags provide exactly this capability. By making GUI dependencies optional and gating them behind a `gui` feature:\n- `cargo build` produces a minimal binary with no GUI deps\n- `cargo build --features gui` includes the full GUI stack\n- Library users can choose whether to include GUI support\n\n## Technical Considerations\n\n### Version Compatibility (Critical)\nThe GUI stack involves multiple crates that share underlying dependencies:\n- `pixels` uses `wgpu` internally for GPU rendering\n- `egui-wgpu` also uses `wgpu` for rendering egui\n- `egui-winit` bridges egui with winit for input handling\n- All must agree on `winit` version for window/event handling\n\nIf versions mismatch, you get:\n- Compile errors from incompatible types\n- Runtime panics from incompatible wgpu device handles\n- Subtle bugs from event handling mismatches\n\n### Recommended Approach\n1. Start with `pixels` as the anchor (it's most constrained)\n2. Check which `wgpu` version `pixels` uses\n3. Find `egui-wgpu` version using same `wgpu` major\n4. Find `egui-winit` version compatible with above\n5. Pin `winit` to version used by `pixels`\n\n### Feature Flag Design\n```toml\n[features]\ndefault = []\ngui = [\"dep:winit\", \"dep:pixels\", \"dep:egui\", \"dep:egui-winit\", \"dep:egui-wgpu\"]\n```\n\nUsing `dep:` syntax (Rust 1.60+) for optional dependencies is cleaner than the old `optional = true` approach.\n\n## Success Criteria\n- [ ] `gui` feature defined in Cargo.toml\n- [ ] All GUI deps are optional, activated only by `gui` feature\n- [ ] `cargo build` succeeds without pulling GUI deps\n- [ ] `cargo build --features gui` succeeds\n- [ ] `cargo tree` shows no GUI deps without feature flag\n\n## Dependencies\nNone - this is the foundational epic.\n\n## Blocks\n- Epic: GUI Module Structure\n- All subsequent GUI implementation work","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T13:30:14.136998073+08:00","created_by":"ren","updated_at":"2026-01-11T14:51:11.95580145+08:00","closed_at":"2026-01-11T14:51:11.95580145+08:00","close_reason":"Epic complete. gui feature defined, all deps optional and version-compatible (pixels 0.15, winit 0.29, egui 0.26). Both build modes verified working."}
{"id":"fractal_explorer-knj","title":"Implement placeholder pattern rendering","description":"# Task: Implement Placeholder Pattern Rendering\n\n**Parent Epic**: Epic: Pixels Rendering Pipeline\n\n## Objective\nFill the pixels frame buffer with a simple pattern to prove the rendering pipeline works. This will be replaced with actual fractal rendering in Milestone 2.\n\n## Implementation\n\n### 1. Simple gradient pattern\n```rust\nfn draw_placeholder(\u0026mut self) {\n    let frame = self.pixels.frame_mut();\n    let width = self.width as usize;\n    \n    for (i, pixel) in frame.chunks_exact_mut(4).enumerate() {\n        let x = i % width;\n        let y = i / width;\n        \n        // Simple gradient based on position\n        pixel[0] = (x % 256) as u8;           // R: varies with x\n        pixel[1] = (y % 256) as u8;           // G: varies with y\n        pixel[2] = 128;                        // B: constant\n        pixel[3] = 255;                        // A: opaque\n    }\n}\n```\n\n### 2. Alternative: Checkerboard (better visibility)\n```rust\nfn draw_placeholder(\u0026mut self) {\n    let frame = self.pixels.frame_mut();\n    let width = self.width as usize;\n    let tile_size = 32;\n    \n    for (i, pixel) in frame.chunks_exact_mut(4).enumerate() {\n        let x = i % width;\n        let y = i / width;\n        \n        let tile_x = x / tile_size;\n        let tile_y = y / tile_size;\n        let is_dark = (tile_x + tile_y) % 2 == 0;\n        \n        let color = if is_dark { 60 } else { 200 };\n        pixel[0] = color;  // R\n        pixel[1] = color;  // G\n        pixel[2] = color;  // B\n        pixel[3] = 255;    // A\n    }\n}\n```\n\n### 3. Call from render\n```rust\nfn render(\u0026mut self) -\u003e Result\u003c(), pixels::Error\u003e {\n    self.draw_placeholder();\n    self.pixels.render()\n}\n```\n\n## Technical Notes\n\n### RGBA format\npixels uses RGBA8 format: 4 bytes per pixel in R, G, B, A order.\n- Alpha should be 255 (opaque) for solid content\n- Alpha = 0 is transparent (but we're not compositing)\n\n### Performance considerations\nThis placeholder is simple and fast. The real fractal renderer (Milestone 2) will be much more expensive, which is why we'll use worker threads and cancellation.\n\n### Deterministic output\nThe pattern should be deterministic (same input → same output). This helps with debugging and testing. Avoid using random values.\n\n### Frame buffer size\n`frame_mut()` returns a slice of exactly `width * height * 4` bytes. Ensure loop bounds match.\n\n## Success Criteria\n- [ ] Pattern fills entire window\n- [ ] No black bars or missing regions\n- [ ] Pattern updates correctly on resize\n- [ ] Colors are visible (not all black/white)\n- [ ] Alpha channel is opaque (no transparency artifacts)\n\n## Dependencies\n- Task: Initialize pixels surface\n\n## Blocks\n- Task: Handle pixels resize","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:34:14.340182388+08:00","created_by":"ren","updated_at":"2026-01-11T20:39:23.452436512+08:00","closed_at":"2026-01-11T20:39:23.452436512+08:00","close_reason":"Implemented checkerboard placeholder pattern rendering - window now visible on Wayland","dependencies":[{"issue_id":"fractal_explorer-knj","depends_on_id":"fractal_explorer-l3o","type":"blocks","created_at":"2026-01-11T13:37:21.247895258+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-l3o","title":"Initialize pixels surface","description":"# Task: Initialize pixels Surface\n\n**Parent Epic**: Epic: Pixels Rendering Pipeline\n\n## Objective\nInitialize the `pixels` crate to create a GPU-backed framebuffer tied to the window surface.\n\n## Implementation\n\n### 1. Create pixels instance\n```rust\nuse pixels::{Pixels, SurfaceTexture};\n\n// In run_gui(), after window creation:\nlet window_size = window.inner_size();\nlet surface_texture = SurfaceTexture::new(\n    window_size.width,\n    window_size.height,\n    \u0026window,\n);\n\nlet pixels = Pixels::new(\n    window_size.width,\n    window_size.height,\n    surface_texture,\n).expect(\"Failed to create pixels\");\n```\n\n### 2. Store in application state\nNeed to refactor to have mutable state:\n```rust\nstruct App {\n    pixels: Pixels,\n    width: u32,\n    height: u32,\n}\n\nimpl App {\n    fn new(window: \u0026Window) -\u003e Self {\n        let size = window.inner_size();\n        let surface_texture = SurfaceTexture::new(size.width, size.height, window);\n        let pixels = Pixels::new(size.width, size.height, surface_texture)\n            .expect(\"Failed to create pixels\");\n        \n        Self {\n            pixels,\n            width: size.width,\n            height: size.height,\n        }\n    }\n}\n```\n\n### 3. Render call\n```rust\n// In RedrawRequested handler:\nfn render(\u0026mut self) {\n    // Fill frame (next task)\n    let frame = self.pixels.frame_mut();\n    // ... fill with pattern ...\n    \n    // Present to window\n    if let Err(e) = self.pixels.render() {\n        eprintln!(\"Render error: {e}\");\n        // Could try to recover or exit\n    }\n}\n```\n\n## Technical Notes\n\n### SurfaceTexture lifetime\n`SurfaceTexture` borrows from `Window`, but `Pixels::new()` consumes it. The resulting `Pixels` instance internally manages the GPU surface.\n\n### Buffer size vs surface size\n- **Buffer**: The dimensions of our pixel data (width × height × 4 bytes)\n- **Surface**: The window's physical size\n\nInitially these match. Later, we might render at lower resolution for performance (render-scale feature).\n\n### Error handling\n`Pixels::new()` can fail if:\n- GPU is unavailable\n- Window surface is invalid\n- Memory allocation fails\n\nFor this milestone, panicking is acceptable. Production code might show a dialog or fall back to software rendering.\n\n### Thread safety\n`Pixels` is NOT Send/Sync. Must be used only from the event loop thread. This is fine for our architecture (fractal rendering on workers, presentation on UI thread).\n\n## Success Criteria\n- [ ] pixels instance created successfully\n- [ ] No GPU errors during initialization\n- [ ] Frame buffer accessible via frame_mut()\n- [ ] render() call succeeds (even with empty frame)\n\n## Dependencies\n- Task: Handle window lifecycle events\n- Epic: Cargo Feature and Dependencies Setup (needs pixels dep)\n\n## Blocks\n- Task: Implement placeholder pattern rendering\n- Task: Handle pixels resize","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:34:11.562277557+08:00","created_by":"ren","updated_at":"2026-01-11T20:39:23.413295939+08:00","closed_at":"2026-01-11T20:39:23.413295939+08:00","close_reason":"Implemented pixels surface initialization with SurfaceTexture tied to window","dependencies":[{"issue_id":"fractal_explorer-l3o","depends_on_id":"fractal_explorer-aue","type":"blocks","created_at":"2026-01-11T13:37:21.224189977+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-lo0","title":"Add GUI dependencies to Cargo.toml","description":"# Task: Add GUI Dependencies to Cargo.toml\n\n**Parent Epic**: Epic: Cargo Feature and Dependencies Setup\n\n## Objective\nAdd all required GUI dependencies as optional deps activated by the `gui` feature.\n\n## Implementation\n\n### 1. Add optional dependencies\n```toml\n[dependencies]\n# ... existing deps ...\n\n# GUI dependencies (optional)\nwinit = { version = \"X.Y\", optional = true }\npixels = { version = \"X.Y\", optional = true }\negui = { version = \"X.Y\", optional = true }\negui-winit = { version = \"X.Y\", optional = true }\negui-wgpu = { version = \"X.Y\", optional = true }\n```\n\n### 2. Wire to feature\n```toml\n[features]\ngui = [\n    \"dep:winit\",\n    \"dep:pixels\", \n    \"dep:egui\",\n    \"dep:egui-winit\",\n    \"dep:egui-wgpu\",\n]\n```\n\nThe `dep:` syntax (Rust 1.60+) explicitly activates optional dependencies.\n\n### 3. Verify isolation\n```bash\n# Without feature - should not pull GUI deps\ncargo tree | grep -E \"(winit|pixels|egui|wgpu)\"\n# Expected: no output\n\n# With feature - should show GUI deps\ncargo tree --features gui | grep -E \"(winit|pixels|egui)\"\n# Expected: shows deps\n```\n\n## Version Selection\nUse versions from \"Research compatible GUI dependency versions\" task.\n\nKey constraints:\n- pixels and egui-wgpu must use same wgpu major version\n- winit version must be consistent across pixels, egui-winit, and direct dep\n- Check docs.rs for each crate's peer dependency requirements\n\n## Success Criteria\n- [ ] All 5 GUI deps added as optional\n- [ ] Feature activates all deps\n- [ ] `cargo build` succeeds (without feature, no GUI code)\n- [ ] `cargo build --features gui` succeeds\n- [ ] Dependency tree clean (no duplicate wgpu/winit versions)\n\n## Dependencies\n- Task: Research compatible GUI dependency versions\n- Task: Add gui feature flag to Cargo.toml\n\n## Blocks\n- Epic: GUI Module Structure (needs deps available)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:32:38.072754747+08:00","created_by":"ren","updated_at":"2026-01-11T14:50:49.181850696+08:00","closed_at":"2026-01-11T14:50:49.181850696+08:00","close_reason":"Added all 5 GUI dependencies as optional. Verified clean dependency tree with single versions of wgpu (0.19.4) and winit (0.29.15). All tests pass.","dependencies":[{"issue_id":"fractal_explorer-lo0","depends_on_id":"fractal_explorer-0sv","type":"blocks","created_at":"2026-01-11T13:37:13.326723555+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-nkj","title":"Create GUI module scaffold","description":"# Task: Create GUI Module Scaffold\n\n**Parent Epic**: Epic: GUI Module Structure\n\n## Objective\nCreate the directory structure and module files for GUI code under `src/input/gui/`.\n\n## Current State\n**Important**: The `src/input/` directory does NOT currently exist. We need to create the entire input module hierarchy from scratch, not just add a gui submodule.\n\nCurrent lib.rs:\n```rust\nmod controllers;\nmod core;\nmod storage;\n\npub use controllers::mandelbrot::mandelbrot_controller;\n```\n\n## Implementation\n\n### 1. Create directory structure\n```bash\nmkdir -p src/input/gui\n```\n\nResults in:\n```\nsrc/\n├── input/\n│   ├── mod.rs          # NEW: declares gui submodule (gated)\n│   └── gui/\n│       ├── mod.rs      # NEW: exports run_gui()\n│       └── app.rs      # NEW: contains event loop (stub for now)\n├── lib.rs              # MODIFY: add input module declaration\n└── ... (existing files)\n```\n\n### 2. Create src/input/mod.rs\n```rust\n//! Input adapters for the fractal explorer.\n//!\n//! This module contains adapters that receive input from various sources\n//! and translate them into domain requests.\n\n#[cfg(feature = \"gui\")]\npub mod gui;\n```\n\n### 3. Create src/input/gui/mod.rs\n```rust\n//! GUI input adapter for interactive fractal exploration.\n//!\n//! This module provides a windowed interface using winit for window management,\n//! pixels for framebuffer rendering, and egui for UI controls.\n\nmod app;\n\npub use app::run_gui;\n```\n\n### 4. Create src/input/gui/app.rs (stub)\n```rust\n//! Main GUI application loop.\n\n/// Runs the GUI application.\n///\n/// This function does not return until the window is closed.\npub fn run_gui() {\n    todo!(\"Implement GUI event loop\")\n}\n```\n\n### 5. Update src/lib.rs\nAdd input module declaration with cfg gating:\n```rust\nmod controllers;\nmod core;\n#[cfg(feature = \"gui\")]\nmod input;\nmod storage;\n\npub use controllers::mandelbrot::mandelbrot_controller;\n\n#[cfg(feature = \"gui\")]\npub use input::gui::run_gui;\n```\n\nNote: The entire `input` module is gated. If we later add non-GUI input adapters (e.g., CLI arg parsing), we'd restructure this.\n\n## Technical Notes\n\n### Module Documentation\nEach module should have doc comments explaining its role:\n- `input/mod.rs`: Overview of input adapters\n- `input/gui/mod.rs`: High-level purpose of GUI adapter\n- `input/gui/app.rs`: Event loop and application state\n\n### Stub Implementation\nUsing `todo!()` macro for initial stub:\n- Compiles successfully\n- Panics at runtime with clear message\n- Will be replaced in Window/Event Loop task\n\n### Why gate entire input module?\nCurrently, the input module only contains GUI code. Gating at the `mod input` level is cleaner than having an always-present but empty module. If we add non-GUI input adapters later, we'd change this to gate only the gui submodule.\n\n## Success Criteria\n- [ ] `src/input/mod.rs` exists\n- [ ] `src/input/gui/mod.rs` exists\n- [ ] `src/input/gui/app.rs` exists\n- [ ] `run_gui()` function is declared (stub is fine)\n- [ ] Module documentation present\n- [ ] Code compiles with `--features gui`\n- [ ] Code does NOT compile without feature (gated correctly)\n\n## Dependencies\n- Task: Add GUI dependencies to Cargo.toml\n\n## Blocks\n- Task: Add feature-gated module declarations\n- Task: Create binary entry point","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:32:38.173077544+08:00","created_by":"ren","updated_at":"2026-01-11T14:54:14.024757284+08:00","closed_at":"2026-01-11T14:54:14.024757284+08:00","close_reason":"Created src/input/gui module scaffold with mod.rs and app.rs. run_gui() stub exported. Feature gating verified working.","dependencies":[{"issue_id":"fractal_explorer-nkj","depends_on_id":"fractal_explorer-lo0","type":"blocks","created_at":"2026-01-11T13:37:16.959040073+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-p7z","title":"Epic: Build Verification and Testing","description":"# Epic: Build Verification and Testing\n\n## Overview\nVerify that the feature-gated build works correctly: non-GUI builds remain lightweight, GUI builds compile and run, and all success criteria from the milestone spec are met.\n\n## Background \u0026 Rationale\n\n### Why Verification Matters\nFeature-gated code is easy to break:\n- Forget a `#[cfg]` attribute → non-GUI build pulls GUI deps\n- Typo in feature name → code never compiles\n- Version mismatch → runtime panic instead of compile error\n\nExplicit verification catches these issues early.\n\n### Verification Strategy\n1. **Isolation check**: Prove non-GUI builds are truly isolated\n2. **Compilation check**: Prove GUI builds compile\n3. **Runtime check**: Prove GUI binary runs correctly\n4. **Manual testing**: Visual verification of success criteria\n\n## Verification Steps\n\n### 1. Non-GUI Build Isolation\n```bash\n# Should succeed without GUI deps\ncargo build\ncargo test\n\n# Should show no GUI crates\ncargo tree | grep -E \"(winit|pixels|egui|wgpu)\"\n# Expected: no output\n```\n\n### 2. GUI Build Compilation\n```bash\n# Should compile with all GUI deps\ncargo build --features gui\n\n# Should show GUI crates only under [gui] feature\ncargo tree --features gui | grep -E \"(winit|pixels|egui)\"\n```\n\n### 3. GUI Binary Execution\n```bash\n# Should open window, show placeholder + egui panel\ncargo run --features gui --bin gui\n```\n\n### 4. Manual Testing Checklist\n- [ ] Window opens with title \"Fractal Explorer\"\n- [ ] Placeholder pattern visible (gradient/colour)\n- [ ] Egui panel visible with label and slider\n- [ ] Slider is interactive (drag changes value)\n- [ ] Resize window → content scales, no crash\n- [ ] Minimize window → no crash\n- [ ] Restore from minimize → content reappears\n- [ ] Close window → clean exit (no panic)\n- [ ] On high-DPI display: text is crisp, not blurry\n\n## Technical Considerations\n\n### CI Integration (Future)\nFor now, manual verification. Future work could add CI jobs:\n```yaml\njobs:\n  build-no-gui:\n    - cargo build\n    - cargo test\n  build-gui:\n    - cargo build --features gui\n  # GUI runtime tests need display server, complex to set up\n```\n\n### Common Failure Modes\n1. **Missing cfg gate**: `cargo build` pulls GUI deps\n   - Fix: Add `#[cfg(feature = \"gui\")]` to module declarations\n   \n2. **Type errors in GUI code**: Non-GUI build fails\n   - Fix: Ensure GUI types don't leak into non-GUI code\n   \n3. **Version mismatch**: GUI build fails with type errors\n   - Fix: Align wgpu versions across pixels/egui-wgpu\n\n4. **Runtime panic**: Window creation fails\n   - Fix: Check error handling, ensure valid window parameters\n\n## Success Criteria\n- [ ] Non-GUI build succeeds (cargo build, cargo test)\n- [ ] No GUI deps in non-GUI dependency tree\n- [ ] GUI build succeeds (cargo build --features gui)\n- [ ] GUI binary runs (cargo run --features gui --bin gui)\n- [ ] All manual testing checklist items pass\n\n## Dependencies\n- Epic: Egui Overlay Integration\n- (Transitively: all other epics)\n\n## Blocks\n- Milestone 2 work (depends on solid foundation)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-11T13:30:52.346301756+08:00","created_by":"ren","updated_at":"2026-01-11T13:30:52.346301756+08:00","dependencies":[{"issue_id":"fractal_explorer-p7z","depends_on_id":"fractal_explorer-51g","type":"blocks","created_at":"2026-01-11T13:36:36.747354282+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-ruf","title":"Complete manual testing checklist","description":"# Task: Complete Manual Testing Checklist\n\n**Parent Epic**: Epic: Build Verification and Testing\n\n## Objective\nRun through the complete manual testing checklist to verify all milestone success criteria are met. Document results.\n\n## Checklist\n\n### Feature Isolation (from spec)\n- [ ] `cargo build` succeeds without `--features gui`\n- [ ] `cargo test` succeeds without `--features gui`\n- [ ] Neither command pulls in `winit`, `pixels`, `egui`, or `wgpu` dependencies\n\n### GUI Binary Runs (from spec)\n- [ ] `cargo run --features gui --bin gui` opens a window\n- [ ] Window displays a placeholder pattern (solid colour or gradient)\n- [ ] Resizing the window updates the rendered pattern without crashes\n\n### Egui Integration Works (from spec)\n- [ ] A minimal egui panel is visible overlaid on the placeholder\n- [ ] The panel contains at least a label and an interactive widget (e.g., slider)\n- [ ] Interacting with the widget updates the UI (e.g., slider value changes)\n\n### Resize/DPI Handling (from spec)\n- [ ] Resizing the window resizes both the pixels surface and buffer\n- [ ] Minimizing to 0×0 does not crash; rendering resumes when restored\n- [ ] High-DPI displays show correctly sized content (if testable)\n\n### Module Structure (from spec)\n- [ ] GUI code lives under `src/input/gui/`\n- [ ] `src/bin/gui.rs` exists and is gated with `required-features = [\"gui\"]`\n- [ ] `src/lib.rs` gates GUI module declarations with `#[cfg(feature = \"gui\")]`\n\n## Test Environments\nDocument where tests were run:\n\n### Environment 1\n- OS:\n- Display:\n- Scale factor:\n- Results:\n\n### Environment 2 (if available)\n- OS:\n- Display:\n- Scale factor:\n- Results:\n\n## Issues Found\nDocument any issues discovered during testing:\n\n1. Issue:\n   - Steps to reproduce:\n   - Expected:\n   - Actual:\n   - Severity: (blocker/major/minor)\n\n## Signoff\n- [ ] All checklist items pass\n- [ ] No blocker issues found\n- [ ] Milestone ready for completion\n\n## Success Criteria\n- [ ] All checklist items verified\n- [ ] Results documented\n- [ ] Any issues logged as separate beads\n- [ ] Milestone success criteria confirmed met\n\n## Dependencies\n- Task: Verify GUI binary functionality\n- Task: Verify non-GUI build isolation\n\n## Blocks\n- Milestone completion\n- Milestone 2 kickoff","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T13:36:01.333420857+08:00","created_by":"ren","updated_at":"2026-01-11T13:36:01.333420857+08:00","dependencies":[{"issue_id":"fractal_explorer-ruf","depends_on_id":"fractal_explorer-ahl","type":"blocks","created_at":"2026-01-11T13:37:26.106009979+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-tfa","title":"Integrate egui rendering with pixels","description":"# Task: Integrate egui Rendering with pixels\n\n**Parent Epic**: Epic: Egui Overlay Integration\n\n## Objective\nUse `pixels::render_with()` to render egui on top of the framebuffer, sharing the same wgpu device and queue. This is the key integration point between our two rendering systems.\n\n## Implementation\n\n### 1. Set up egui-wgpu renderer\n```rust\nuse egui_wgpu::Renderer as EguiRenderer;\n\nstruct App {\n    // ... existing fields ...\n    egui_renderer: EguiRenderer,\n}\n\nimpl App {\n    fn new(window: \u0026Window, event_loop: \u0026EventLoop\u003c()\u003e) -\u003e Self {\n        // After creating pixels...\n        let egui_renderer = EguiRenderer::new(\n            pixels.device(),\n            pixels.render_texture_format(),\n            None, // depth format\n            1,    // msaa samples\n            true, // dithering\n        );\n        \n        // ...\n    }\n}\n```\n\n### 2. Use render_with() for egui pass\n```rust\nfn render(\u0026mut self, window: \u0026Window) -\u003e Result\u003c(), pixels::Error\u003e {\n    if self.width == 0 || self.height == 0 {\n        return Ok(());\n    }\n    \n    // Draw our content\n    self.draw_placeholder();\n    \n    // Run egui frame\n    let full_output = self.update_ui(window);\n    \n    // Process egui output (handle cursor, clipboard, etc.)\n    self.egui_state.handle_platform_output(window, full_output.platform_output);\n    \n    // Render with egui overlay\n    let clipped_primitives = self.egui_ctx.tessellate(\n        full_output.shapes,\n        self.egui_ctx.pixels_per_point(),\n    );\n    \n    self.pixels.render_with(|encoder, render_target, context| {\n        // Update egui textures\n        for (id, delta) in \u0026full_output.textures_delta.set {\n            self.egui_renderer.update_texture(\n                context.device,\n                context.queue,\n                *id,\n                delta,\n            );\n        }\n        \n        // Update egui buffers\n        let screen_descriptor = egui_wgpu::ScreenDescriptor {\n            size_in_pixels: [self.width, self.height],\n            pixels_per_point: self.egui_ctx.pixels_per_point(),\n        };\n        \n        self.egui_renderer.update_buffers(\n            context.device,\n            context.queue,\n            encoder,\n            \u0026clipped_primitives,\n            \u0026screen_descriptor,\n        );\n        \n        // Render egui\n        let mut render_pass = encoder.begin_render_pass(\u0026wgpu::RenderPassDescriptor {\n            label: Some(\"egui\"),\n            color_attachments: \u0026[Some(wgpu::RenderPassColorAttachment {\n                view: render_target,\n                resolve_target: None,\n                ops: wgpu::Operations {\n                    load: wgpu::LoadOp::Load, // Don't clear, keep pixels content\n                    store: wgpu::StoreOp::Store,\n                },\n            })],\n            depth_stencil_attachment: None,\n            ..Default::default()\n        });\n        \n        self.egui_renderer.render(\n            \u0026mut render_pass,\n            \u0026clipped_primitives,\n            \u0026screen_descriptor,\n        );\n        \n        // Clean up freed textures\n        for id in \u0026full_output.textures_delta.free {\n            self.egui_renderer.free_texture(id);\n        }\n        \n        Ok(())\n    })\n}\n```\n\n## Technical Notes\n\n### render_with() API\n`pixels.render_with()` gives us access to:\n- `encoder`: wgpu::CommandEncoder for GPU commands\n- `render_target`: The texture view to render to\n- `context`: Contains device, queue, and other GPU resources\n\nWe render egui AFTER pixels has drawn, using `LoadOp::Load` to preserve the framebuffer.\n\n### Texture format matching\nCritical: egui-wgpu must use the same texture format as pixels:\n```rust\nlet format = pixels.render_texture_format();\n```\n\nMismatched formats cause validation errors.\n\n### Memory management\negui-wgpu caches textures (fonts, user images). The `textures_delta` provides:\n- `set`: Textures to upload/update\n- `free`: Textures to delete\n\nProcess both for correct memory management.\n\n### Screen descriptor\nTells egui the render target size and DPI:\n```rust\nScreenDescriptor {\n    size_in_pixels: [width, height],\n    pixels_per_point: scale_factor,\n}\n```\n\nMust match actual render target for correct positioning.\n\n## Success Criteria\n- [ ] egui renders on top of pixels content\n- [ ] egui text is crisp (not blurry)\n- [ ] egui panels have correct transparency\n- [ ] No z-fighting or flickering\n- [ ] No GPU validation errors\n- [ ] Memory doesn't leak (textures freed properly)\n\n## Dependencies\n- Task: Set up egui context and input handling\n- Task: Handle pixels resize and edge cases\n\n## Blocks\n- Task: Create minimal UI panel","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T13:35:47.92668426+08:00","created_by":"ren","updated_at":"2026-01-11T13:35:47.92668426+08:00","dependencies":[{"issue_id":"fractal_explorer-tfa","depends_on_id":"fractal_explorer-j4n","type":"blocks","created_at":"2026-01-11T13:37:23.245263308+08:00","created_by":"ren"}]}
{"id":"fractal_explorer-y8r","title":"Implement winit event loop skeleton","description":"# Task: Implement winit Event Loop Skeleton\n\n**Parent Epic**: Epic: Window and Event Loop\n\n## Objective\nReplace the `todo!()` stub in `app.rs` with a functional winit event loop that creates a window and handles basic events.\n\n## Implementation\n\n### 1. Basic event loop structure\n```rust\nuse winit::{\n    event::{Event, WindowEvent},\n    event_loop::EventLoop,\n    window::WindowBuilder,\n    dpi::LogicalSize,\n};\n\npub fn run_gui() {\n    let event_loop = EventLoop::new().expect(\"Failed to create event loop\");\n    \n    let window = WindowBuilder::new()\n        .with_title(\"Fractal Explorer\")\n        .with_inner_size(LogicalSize::new(800.0, 600.0))\n        .with_min_inner_size(LogicalSize::new(200.0, 200.0))\n        .build(\u0026event_loop)\n        .expect(\"Failed to create window\");\n    \n    event_loop.run(|event, elwt| {\n        match event {\n            Event::WindowEvent { event, window_id } \n                if window_id == window.id() =\u003e \n            {\n                match event {\n                    WindowEvent::CloseRequested =\u003e {\n                        elwt.exit();\n                    }\n                    WindowEvent::RedrawRequested =\u003e {\n                        // Will render here\n                        // window.request_redraw(); // For continuous, but we want on-demand\n                    }\n                    _ =\u003e {}\n                }\n            }\n            Event::AboutToWait =\u003e {\n                // Request redraw only if state changed\n                // For now, always request to keep simple\n                window.request_redraw();\n            }\n            _ =\u003e {}\n        }\n    }).expect(\"Event loop error\");\n}\n```\n\n### 2. winit API version notes\nwinit 0.29+ changed the event loop API:\n- `EventLoop::new()` returns `Result`\n- `event_loop.run()` takes `|event, elwt|` not `|event, _, control_flow|`\n- Use `elwt.exit()` instead of `*control_flow = ControlFlow::Exit`\n\nCheck which winit version we're using and adjust accordingly.\n\n### 3. Initial redraw\nRequest first redraw after setup:\n```rust\n// After window creation, before event_loop.run()\nwindow.request_redraw();\n```\n\nOr handle it in the first `AboutToWait` event.\n\n## Technical Notes\n\n### Event Loop Ownership\n`event_loop.run()` takes ownership and never returns (on most platforms). This is why `run_gui()` has no return value for now.\n\n### Window Lifetime\nThe window must outlive the event loop. In this structure, both are owned by `run_gui()` so this is automatic.\n\n### Error Handling\nUsing `.expect()` for now. Production code might:\n```rust\npub fn run_gui() -\u003e Result\u003c(), GuiError\u003e { ... }\n```\n\nFor this milestone, panicking on setup failure is acceptable.\n\n## Success Criteria\n- [ ] Window opens with \"Fractal Explorer\" title\n- [ ] Window has reasonable initial size (800x600)\n- [ ] Window has minimum size constraint\n- [ ] Close button exits cleanly (no panic)\n- [ ] Event loop runs without busy-looping\n\n## Dependencies\n- Task: Create binary entry point (gui.rs)\n- Epic: Cargo Feature and Dependencies Setup (needs winit dep)\n\n## Blocks\n- Task: Handle window lifecycle events","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:34:11.324903184+08:00","created_by":"ren","updated_at":"2026-01-11T15:48:08.094855144+08:00","closed_at":"2026-01-11T15:48:08.094855144+08:00","close_reason":"Implemented winit event loop with window creation, close handling, and redraw-on-demand pattern","dependencies":[{"issue_id":"fractal_explorer-y8r","depends_on_id":"fractal_explorer-a13","type":"blocks","created_at":"2026-01-11T13:37:19.364451623+08:00","created_by":"ren"}]}
